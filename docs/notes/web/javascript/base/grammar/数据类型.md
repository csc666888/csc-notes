# 数据类型
ECMAScript有6中简单的数据类型（原始类型）：`Undefined、Null、Boolean、Number、String、Symbol`。还有一种复杂的数据类型`Object`（对象）。

## 1.typeof操作符
ECMAScript的类型系统是松散的，所以需要一种手段类确定任意变量的数据类型。对一个值使用`typeof`操作符会返回以下字符串。

- "undefined" 表示值未定义；
- "boolean" 表示值为布尔值；
- "string" 表示值为字符串；
- "number" 表示值为数值；
- "object" 表示值为对象（而不是函数）或null；
- "function" 表示值为函数；
- "symbol" 表示值为符号；

```js
const message = 'Tom';
console.log(typeof message); // string
console.log(typeof(message)); // string
console.log(typeof 18); // number
```
:::warning
1.因为`typeof`是操作符而不是函数，所以不需要参数（但是可以传递参数）；

2.函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己的特殊属性，为此，就必须通过`typeof`操作符来区分函数和其他对象。
:::

## 2.Undefined类型
`Undefined`类型只有一个值，就是特殊值`undefined`。当使用`var`或`let`声明了变量但没有初始化时，就相当于给变量赋值了`undefined`值。
```js
let message;
console.log(message == undefined); // true
```
:::warning
一般来说，永远不用显式地给某个变量设置`undefined`值。字面量`undefined`主要用于比较，增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。
:::
```js
let message;
console.log(message); // undefined
console.log(age); // 报错
typeof(age); // undefined
```
对于未声明的变量，只能执行一个有用的操作，就是对它使用`typeof`。返回的结果是`undefined`。无论声明还是未声明，`typeof`返回都是字符串`'undefined'`。逻辑上是对的，虽然严格来说这两种变量存在根本上的差异，但它对任何一个变量都不可能执行任何真正的操作。

:::warning
即使未初始化的变量会被自动赋值为`undefined`值，但仍然建议在声明变量的同时进行初始化。这样，当`typeof`返回`'undefined'`时，就可以知道那是因为给定的变量尚未声明，而不是变量声明了但未初始化。
:::
`undefined`是一个假值（布尔值中的false），因此，可以用更简洁的方式检测它。不过很多其他类型的值同样是假值。所以一定要明确想要检测的就是`undefined`字面量，而不仅仅是假值。
```js
let message;
if(message){
  // 不会被执行
}
if(!message) {
  // 会被执行
}
if(age) {
  // 报错 age没有声明
}
```
## 3.Null类型
`Null`类型同样只有一个值，即特殊值`null`。逻辑上讲，`null`值表示一个空对象指针，这也是给`typeof`传一个`null`会返回`object`的原因。
```js
let car = null;
console.log(typeof car); // object
```
在定义将来要保存对象值的变量时，建议使用`null`来初始化，不要使用其他值。这样，只要检查这个变量的值是不是`null`就可以知道这个变量是否在后来被重新赋予了一个对象的引用。
```js
if(car != null) {

}
```
`undefined`值是由`null`值派生来的，因此ECMAScript将他们定义为表面上相等。
```js
console.log(undefined == null); // true
```
用`==`操作符，比较`null`和`undefined`始终返回`true`。但要注意，这个操作符会为了比较而转化它的操作数。
任何时候，只要变量要保存对象，而当时又没有那个对象可以保存，就可以用`null`来初始化变量，这样就可以保持`null`是空对象指针的语义，并进一步将其与`undefined`区分开来。

## 4.Boolean类型
`Boolean`类型有两个字面值：`true`和`false`。这两个布尔值不同于数值，因此`true`不等于1，`false`不等于0
```js
let found = true;
let lost = false;
```
:::warning
布尔值字面量`true`和`flase`是区分大小写的，因此`True`和`False`以及其他的大小混合形式都是有效标识符，而不是布尔值。
:::
虽然布尔值只有两个，但所有其他类型的值都有相应布尔值的等价形式。要将一个其他类型的值转为布尔值，可以使用`Boolean()`转型函数。
```js
let message = 'Tom';
let messageBoolean = Boolean(message);
```
什么值能转成`true`或`flase`的规则取决于数据类型和实际值。

|数据类型|转为true的值|转为false的值|
| :---: | :---: | :---: |
|Boolean|true|flase|
|String|非空字符串|""（空字符串）|
|Number|非零数值（包括无穷值）|0、NAN|
|Object|任意对象|null|
|Undefined|/|undefined|

上述转化非常重要，像`if`等控制流语句会自动执行其他类型到布尔值的转化。

## 5.Number类型
`Number`类型既可以表示整数也可以表示浮点数
```js
let num1 = 10;
let num2 = 0.1;
```
:::warning
由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都认识是等同的。
:::
### 5.1浮点值
要定义浮点数，数值中必须包含小数点，而且小数点后面必须至少有一个数字。
```js
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效但不推荐
```
因为储存浮点值使用的内存空间是存储整数的两倍，所以JavaScript引擎总是设法将值转成整数。在小数点后面没有数组的情况下，数值就会变成整数。类似的，如果数值本身就是整数，只是小数点后面跟着0，那它也会被转成整数。
```js
let floatNum1 = 1.;
let floatNum2 = 10.0;
```
对于非常大或非常小的浮点数，可以使用科学计数法来表示。
```js
let floatNum1 = 1.2e3; // 表示 1200  1.2 * 10的多少次幂
let floatNum2 = 1.2e-3 // 表示 0.0012
```
浮点值的精确度最高可达17位数，但在算数计算中远不如整数精确。例如 0.1 + 0.2 得不到0.3。由于这种微小的舍入错误，导致很难测试特定的浮点值。
:::warning
之所以存在这种错误，是因为使用了IEEE 745数值，这种错误并非JavaScript独有，其他使用相同格式的语言也有这种问题。
:::
### 5.2值的范围
由于内存的限制，数字类型并不支持世界上所有的数值，它将最小的数值保存在`Number.MIN_VALUE`中，最大值保存在`Number.MAX_VALUE`中。如果某个计算得到的数值结果超过了JavaScript可以表示的范围，那么这个值会被自动转化为一个特殊的`Infinity(无穷)值`。任何无法表达的负数以`-Infinity`表示。任何无法表达的整数以`Infinity`表示。

要确定一个值是不是有限大，可以使用`isFinite()`函数
```js
let result = Number.Max_VALUE;
console.log(isFinite(result)); // false
```
### 5.3NaN
有个特殊的数值`NaN`，意思是“不是数值”(Not a Number),用于表示本来要返回数值的操作失败了（而不是错误）。
```js
console.log(0/0); // NaN
```
如果分子是非零，分母是有符号或无符号的0，则会返回`Infinity`或`-Infinity`。
```js
console.log(5/0); // Infinity
console.log(-5/0); // -Infinity
```
`NaN`有几个独特的属性，首先任何涉及`NaN`的操作始终返回`NaN`（NaN/10），其次`NaN`不等于包括`NaN`在内的所有值。
```js
console.log(NaN == NaN); // false
```
JavaScript提供了一个函数`isNaN()`函数，该函数接受一个参数，可以是任何数类型，然后判断这个参数是否是`NaN`。
```js
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false
console.log(isNaN("10")); // false
console.log(isNaN("Tom")); // true Tom不可以转换为数值
console.log(isNaN(true)); // true可以转成数字1 它不是NaN
```
:::warning
虽然不常见，但是isNaN()可以测试对象。此时会首先调用对象的valueOf()方法，然后再确定返回的值是否可以转化为数值。如果不能，再调用toString()方法，并测试其返回值，这通常是ECMAScript内置函数和操作符的工作方式。
:::
### 5.4数值转化
有三个函数可以将非数值转化为数值：`Number()`、`parseInt()`、`parseFloat()`。`Number()`是转型函数，可以用于任何数据类型。后面两个函数主要用于将字符串转成数值。对于同样参数，这三个函数执行的操作也有区别。

`Number()`函数转化规则
- 布尔值，true转化为1，false转化为0。
- 数值直接返回。
- null，返回0。
- undefined，返回NaN。
- 字符串比较复杂
  - 如果字符串包含数值字符，包括数值字符串前面加、减号情况，则转化为一个十进制的数值。因此 `Number("1")`返回1, `Number("011")`返回11（忽略前面的零）。
  - 如果字符串包含有效的浮点值格式，如`1.1`，则会转化为相应的浮点值（同样忽略前面的零）。
  - 如果字符串包含有效的十六进制格式如`0xf`,则会转化为与该十六进制对应的十进制整数值。
  - 如果是空字符串（不包含字符），返回0。
  - 如果字符串包含除上述外的其他字符，则返回`NaN`。
- 对象，调用`valueOf()`方法，并按照上述规则转化返回的值，如果结果是`NaN`则调用`toString()`方法，在按照上述规则转化。
```js
let num1 = Number("Tom"); // NaN
let num2 = Number(""); // 0
let num3 = Number("0001"); // 1
let num4 = Number(true); // 1
```
考虑到用`Number()`函数转化字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用`parseInt()`函数，`parseInt()`函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符串开始转化。如果第一个字符不是数值字符、加号、减号，立即返回`NaN`。这就意味着空字符串也会返回`NaN`（这一点跟Number()不一样，它返回0）,如果第一个字符是数值、加号、减号，则继续以此检测每个字符，直到字符串末尾，或碰到非数值字符。如`111abc`会被转化为`111`。类似的`18.5`会被转化为`18`。因为小数点不是有效整数字符。

假设字符串中的第一个字符是数值字符，`parseInt()`函数也能识别不同整数格式（十进制、八进制、十六进制）。如果字符串以`0x`开头，就会被理解为十六进制整数。如果以`0`开头且紧跟着数值字符，就会被理解为八进制整数。
```js
let num1 = parseInt("123red"); // 123
let num2 = parseInt(""); // NaN
let num3 = parseInt("0xA"); // 10 解释为十六进制整数
let num4 = parseInt("18.5"); // 18
let num5 = parseInt("70"); // 70
```
不同的数值格式很容易混淆，因此`parseInt()`也接受第二个参数，用于指定底数（进制数）。如果要知道解释的值是十六进制，可以传入第二个参数`16`。
```js
let num = parseInt("0xAF", 16); // 175
```
如果提供了第二个参数前面的`0X`就可以去掉
```js
let num = parseInt("AF", 16); // 175
let num = parseInt("AF"); // NaN
```
`parseFloat()`函数的工作方式与`parseInt()`函数类似，都是从0位置开始检测每个字符，解析到字符串末尾或者解析到一个无效的浮点数值为止。
`parseFloat()`函数的不同之处在于，它始终忽略字符串开头的0。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终返回0。因为`parseFloat()`只解析十进制值，因此不能指定底数。如果字符串表示整数（没有小数点或小数点后面只有一个0），则返回整数。
```js
let num1 = parseFloat("1235Tom"); // 1235 按照整数解析
let num2 = parseFloat("0xA"); // 0
let num3 = parseFloat("22.5"); // 22.5
let num4 = parseFloat("22.34.5"); // 22.34
let num5 = parseFloat("0908.5"); // 908.5
let num6 = parseFloat("3.1e3"); // 3100
```
## 6.String类型
`String(字符串)`数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号、单引号、反引号表示。
```js
let str1 = 'Tom';
let str2 = "Tom";
let str3 = `Tom`;
```
### 6.1字符串字面量
|字面量|含义|
| :--: | :--: |
|\n|换行符|
|\t|制表符|
|\b|退格符|
|\r|回车符|
|\f|换页符|
| \\ |反斜杠（\）|
|\'|单引号（'），在字符串以单引号表示时使用，'Tom say, \'hello\''|
| \" |双引号|
|\`|反引号|
|\xnn|以十六进制编码nn表示的字符（其中n是十六进制数字0~F），\x41 等于 A|
|\unnnn|以十六进制编码nnnn表示的Unicode字符（其中n是十六进制数字0~F）， \u03a3等于希腊字 Σ|

这些字符字面量可以出现在字符串的任意位置，且可以作为单个字符被解释。
```js
let text = '你好，世界，\u03a3';
```
即使包含6个字符长的转义序列，变量text仍然是7个字符长。因为转义序列表示一个字符，所以只算一个长度。

字符串的长度可以通过`length`属性获取
```js
console.log(text.length); // 7
```

:::warning
如果字符串中包含双字节字符，那么`length`属性返回的值可能不是准确的字符数。
:::

### 6.2字符串的特点
字符串是不可变的，一旦创建，它们的值就不变了。要修改某个变量中的字符串，必须先销毁原始字符串，然后将包含新的字符串重新保存到该变量。
### 6.3转化为字符串
有两种方式把一个值转化为字符串。首先是几乎所有值都有的`toString()`方法。这个方法唯一的用途就是返回当前值的字符串等价物。
```js
let age = 11;
let ageString = age.toString(); // 字符串 "11"
let flag = true;
let flagString = true.toString(); // 字符串 "true"
```
`toString()`方法可见于数值、布尔值、对象和字符串值（是的，字符串也有这个方法，该方法返回这个字符串本身的一个副本）。`null`和`undefined`没有这个方法。

多数情况下，`toString()`不接受任何参数。不过，在对数值调用这个方法时，`toString()`可以接受一个底数参数，就是告诉`toString()`方法,输出的数值以什么底数表示字符串，默认情况下是十进制字符串表示，也可以是八进制、二进制、十六进制，或其他任何有效基数的字符串表示。
```js
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
console.log(num.toString(10)); // "10"
console.log(num.toString(16)); // "a"
```
如果不确定一个值是不是`null`或`undefined`，可以使用`String()`转型函数，它始终返回表示相应类型的字符串。下面请看转化规则。
- 如果该值有`toString()`方法，则调用该方法并返回结果。
- 如果是`null`返回 "null"
- 如果是`undefined`返回"undefined"
```js
let value1 = 10;
let value2 = true;
let value3 = null;
let value4;
console.log(String(value1)); // "10"
console.log(String(value2)); // "true"
console.log(String(value3)); // "null"
console.log(String(value4)); // "undefined"
```
:::tip
用加号操作符给一个值加上一个空字符串""也可以将其转化为字符串。
:::
### 6.4模板字面量
ES6新增了使用模板字面量定义字符串的能力。与单引号和双引号不同，模板字面量保留换行符，可以跨行定义字符串。
```js
let str1 = "first line \n seconde line";
let str2 = `
first line
seconde line
`;
```
模板字面量在定义模板时特别有用，比如下面的HTML模板
```js
let page = `
<div>
  <a href="#">
    <span> Tom </span>
  </a>
</div>
`;
```
由于模板字面量会保持反引号内部的空格，因此在使用空格的时候要注意。










<style>
  table {
    margin: 0 auto;
  }
</style>